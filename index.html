<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PathFinder — Search Playground</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg-page: #f3f4ff;
      --bg-shell: #f9fafb;
      --bg-panel: #ffffff;
      --bg-soft: #f3f4f6;
      --border-subtle: #e5e7eb;
      --border-strong: #cbd5f5;
      --text-main: #111827;
      --text-muted: #6b7280;
      --accent: #6366f1;
      --accent-soft: rgba(99, 102, 241, 0.08);
      --accent-strong: #4f46e5;
      --chip-bg: #e0e7ff;
      --chip-active-bg: #4f46e5;
      --chip-active-text: #f9fafb;
      --start: #22c55e;
      --end: #ef4444;
      --wall: #e5e7eb;
      --visited: #93c5fd;
      --path: #facc15;
      --grid-border: #e5e7eb;
      --radius-lg: 20px;
      --radius-md: 999px;
      --shadow-strong: 0 24px 80px rgba(15, 23, 42, 0.14);
      font-family: system-ui, -apple-system, Inter, system-ui, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #e0e7ff 0, #eef2ff 40%, #e5e7eb 100%);
      color: var(--text-main);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px 16px;
    }

    /* Frame + high-level animation */

    .app-frame {
      width: 100%;
      max-width: 1140px;
      background: var(--bg-shell);
      border-radius: 28px;
      box-shadow: var(--shadow-strong);
      border: 1px solid var(--border-subtle);
      padding: 18px 18px 16px;
      animation: floatIn 0.8s ease-out forwards;
      opacity: 0;
      transform: translateY(12px) scale(0.98);
    }

    @keyframes floatIn {
      0% {
        opacity: 0;
        transform: translateY(16px) scale(0.97);
      }
      60% {
        opacity: 1;
        transform: translateY(0) scale(1.01);
      }
      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    /* Top bar */

    .topbar {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: center;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border-subtle);
      animation: slideDown 0.7s ease-out 0.15s forwards;
      opacity: 0;
      transform: translateY(-10px);
    }

    @keyframes slideDown {
      0% {
        opacity: 0;
        transform: translateY(-10px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .brand-mark {
      width: 34px;
      height: 34px;
      border-radius: 12px;
      background: conic-gradient(from 210deg, #4ade80, #38bdf8, #6366f1, #f97316, #facc15, #4ade80);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }

    .brand-mark-inner {
      width: 26px;
      height: 26px;
      border-radius: 9px;
      background: #ffffff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      font-weight: 600;
      color: #4f46e5;
    }

    .brand-text {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .brand-name {
      font-size: 1.1rem;
      font-weight: 600;
      letter-spacing: 0.03em;
    }

    .brand-sub {
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .tag-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.78rem;
      color: var(--text-muted);
    }

    .pill {
      padding: 4px 10px;
      border-radius: var(--radius-md);
      border: 1px solid var(--border-subtle);
      background: #ffffff;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-size: 0.7rem;
    }

    .dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 0 5px rgba(34, 197, 94, 0.18);
    }

    /* Layout */

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 3fr) minmax(260px, 1.25fr);
      gap: 16px;
      margin-top: 12px;
    }

    .panel {
      background: var(--bg-panel);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-subtle);
      padding: 12px 12px 10px;
    }

    /* Controls */

    .controls {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 10px;
    }

    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .label {
      font-size: 0.78rem;
      color: var(--text-muted);
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    select,
    button {
      border-radius: var(--radius-md);
      border: 1px solid var(--border-subtle);
      background: #ffffff;
      color: var(--text-main);
      font-size: 0.85rem;
      padding: 8px 12px;
      cursor: pointer;
    }

    select {
      min-width: 190px;
    }

    button.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: #ffffff;
      font-weight: 500;
      box-shadow: 0 8px 20px rgba(99, 102, 241, 0.3);
      position: relative;
      overflow: hidden;
    }

    button.primary::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 0 0, rgba(255, 255, 255, 0.4), transparent 55%);
      opacity: 0;
      transform: translateX(-40%);
      transition: opacity 0.2s ease, transform 0.35s ease;
    }

    button.primary:hover::after {
      opacity: 1;
      transform: translateX(40%);
    }

    button.secondary {
      background: var(--bg-soft);
      border-color: var(--border-subtle);
    }

    button:disabled {
      opacity: 0.55;
      cursor: default;
      box-shadow: none;
    }

    /* Tool chips */

    .tool-chips {
      display: inline-flex;
      flex-wrap: wrap;
      gap: 6px;
      padding: 4px;
      border-radius: 999px;
      background: #eef2ff;
      border: 1px solid #e0e7ff;
    }

    .tool-chip {
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.78rem;
      border: none;
      background: var(--chip-bg);
      color: #4b5563;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      transition: background 0.15s ease, color 0.15s ease, transform 0.08s ease;
    }

    .tool-chip span.key {
      font-size: 0.7rem;
      padding: 0 6px;
      border-radius: 999px;
      background: #e5e7eb;
      color: #4b5563;
    }

    .tool-chip.active {
      background: var(--chip-active-bg);
      color: var(--chip-active-text);
      transform: translateY(-1px);
    }

    .tool-chip.active span.key {
      background: rgba(255, 255, 255, 0.16);
      color: #e5e7eb;
    }

    /* Grid shell + animated border */

    .grid-shell {
      margin-top: 6px;
      border-radius: 18px;
      padding: 10px;
      position: relative;
      background: #ffffff;
      overflow: hidden;
    }

    .grid-shell::before {
      content: "";
      position: absolute;
      inset: -2px;
      border-radius: inherit;
      background: conic-gradient(
        from 180deg,
        rgba(99, 102, 241, 0.7),
        rgba(56, 189, 248, 0.6),
        rgba(45, 212, 191, 0.6),
        rgba(250, 204, 21, 0.6),
        rgba(99, 102, 241, 0.7)
      );
      z-index: 0;
      opacity: 0.45;
      animation: borderSweep 12s linear infinite;
    }

    .grid-shell::after {
      content: "";
      position: absolute;
      inset: 1px;
      border-radius: inherit;
      background: linear-gradient(135deg, #eef2ff, #ffffff);
      z-index: 1;
    }

    @keyframes borderSweep {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }

    #grid {
      position: relative;
      z-index: 2;
      display: grid;
      grid-template-columns: repeat(30, 22px);
      gap: 2px;
      justify-content: center;
      animation: gridFade 0.8s ease-out 0.25s forwards;
      opacity: 0;
      transform: translateY(6px);
    }

    @keyframes gridFade {
      0% {
        opacity: 0;
        transform: translateY(6px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .cell {
      width: 22px;
      height: 22px;
      background: var(--bg-soft);
      border-radius: 5px;
      border: 1px solid var(--grid-border);
      cursor: pointer;
      opacity: 0;
      transform: translateY(8px) scale(0.92);
      animation: cellIn 0.5s ease-out var(--delay, 0s) forwards;
      transition: background 0.12s ease, border-color 0.12s ease, transform 0.08s ease;
    }

    @keyframes cellIn {
      0% {
        opacity: 0;
        transform: translateY(8px) scale(0.92);
      }
      60% {
        opacity: 1;
        transform: translateY(-2px) scale(1.02);
      }
      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .cell:hover {
      transform: translateY(-1px) scale(1.02);
    }

    .cell.wall {
      background: var(--wall);
      border-color: #d1d5db;
    }

    .cell.start {
      background: var(--start);
      border-color: #16a34a;
    }

    .cell.end {
      background: var(--end);
      border-color: #b91c1c;
    }

    .cell.visited {
      background: var(--visited);
      border-color: #60a5fa;
    }

    .cell.path {
      background: var(--path);
      border-color: #eab308;
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      font-size: 0.78rem;
      color: var(--text-muted);
      margin-top: 8px;
      padding: 0 2px;
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .legend-dot {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      border: 1px solid #d1d5db;
    }

    .legend-dot.start { background: var(--start); border-color: #16a34a; }
    .legend-dot.end { background: var(--end); border-color: #b91c1c; }
    .legend-dot.wall { background: var(--wall); }
    .legend-dot.visited { background: var(--visited); border-color: #60a5fa; }
    .legend-dot.path { background: var(--path); border-color: #eab308; }

    /* Right panel – collapsible guide */

    .right-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }

    .right-title {
      font-size: 0.92rem;
      font-weight: 600;
    }

    .guide-toggle {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: #f9fafb;
      font-size: 0.78rem;
      padding: 4px 10px;
      cursor: pointer;
      color: var(--text-muted);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .guide-toggle span.icon {
      display: inline-block;
      transition: transform 0.2s ease;
    }

    .guide-toggle.open span.icon {
      transform: rotate(90deg);
    }

    .guide-body {
  margin-top: 4px;
}

    .body-text {
      font-size: 0.82rem;
      color: var(--text-muted);
      line-height: 1.45;
      margin: 0 0 6px;
    }

    .body-text strong {
      color: var(--text-main);
      font-weight: 600;
    }

    .steps {
      margin: 0 0 6px;
      padding-left: 16px;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .steps li {
      margin-bottom: 3px;
    }

    kbd {
      display: inline-block;
      padding: 1px 5px;
      border-radius: 4px;
      border: 1px solid #d1d5db;
      font-size: 0.74rem;
      background: #f9fafb;
      margin: 0 1px;
      color: #374151;
    }

    .algo-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
      font-size: 0.8rem;
      margin-top: 6px;
    }

    .algo-card {
      border-radius: 12px;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
      padding: 6px 8px;
    }

    .algo-name {
      font-weight: 500;
      margin-bottom: 2px;
      font-size: 0.8rem;
    }

    .algo-desc {
      font-size: 0.78rem;
      color: var(--text-muted);
    }

    .hint {
      font-size: 0.76rem;
      color: var(--text-muted);
      margin-top: 6px;
    }

    @media (max-width: 900px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 640px) {
      .app-frame {
        padding: 16px 12px 12px;
        border-radius: 20px;
      }

      .topbar {
        flex-direction: column;
        align-items: flex-start;
      }

      #grid {
        transform: scale(0.9);
        transform-origin: top left;
      }
    }
  </style>
</head>
<body>
  <div class="app-frame">
    <!-- Top bar -->
    <header class="topbar">
      <div class="brand">
        <div class="brand-mark">
          <div class="brand-mark-inner">PF</div>
        </div>
        <div class="brand-text">
          <div class="brand-name">PathFinder</div>
          <div class="brand-sub">
            A search playground for BFS, DFS, Dijkstra and A* on a 2D grid.
          </div>
        </div>
      </div>
      <div class="tag-row">
        <div class="pill">Vanilla JS · Algorithms</div>
        <div class="dot"></div>
        <span>Built by Pragathi</span>
      </div>
    </header>

    <main class="layout">
      <!-- LEFT: Grid & controls -->
      <section class="panel">
        <div class="controls">
          <div class="controls-row">
            <div class="field">
              <span class="label">Algorithm</span>
              <select id="algo-select">
                <option value="bfs">Breadth-First Search (BFS)</option>
                <option value="dfs">Depth-First Search (DFS)</option>
                <option value="dijkstra">Dijkstra</option>
                <option value="astar">A* Search</option>
              </select>
            </div>

            <button id="run" class="primary">Run Algorithm</button>
            <button id="reset" class="secondary">Reset Grid</button>
          </div>

          <div class="controls-row">
            <span class="label">Tools</span>
            <div class="tool-chips">
              <button type="button" class="tool-chip active" id="tool-wall">
                Walls
                <span class="key">Click</span>
              </button>
              <button type="button" class="tool-chip" id="tool-start">
                Start
                <span class="key">S</span>
              </button>
              <button type="button" class="tool-chip" id="tool-end">
                End
                <span class="key">E</span>
              </button>
            </div>
          </div>
        </div>

        <div class="grid-shell">
          <div id="grid"></div>
        </div>

        <div class="legend">
          <div class="legend-item">
            <span class="legend-dot start"></span> Start
          </div>
          <div class="legend-item">
            <span class="legend-dot end"></span> End
          </div>
          <div class="legend-item">
            <span class="legend-dot wall"></span> Wall
          </div>
          <div class="legend-item">
            <span class="legend-dot visited"></span> Visited
          </div>
          <div class="legend-item">
            <span class="legend-dot path"></span> Path
          </div>
        </div>
      </section>

      <!-- RIGHT: Collapsible guide -->
      
         <aside class="panel">
  <div class="right-header">
    <div class="right-title">Guide & intuition</div>
  </div>

  <div id="guide-body" class="guide-body">
    <p class="body-text">
      Build a small maze, choose a search algorithm, and see how it explores the grid and constructs a path to the goal.
    </p>
    <ul class="steps">
      <li><strong>Draw walls:</strong> Use <strong>Walls</strong> tool and click cells to toggle obstacles.</li>
      <li><strong>Place Start:</strong> Select <strong>Start</strong> tool (or press <kbd>S</kbd>) then click a cell.</li>
      <li><strong>Place End:</strong> Select <strong>End</strong> tool (or press <kbd>E</kbd>) then click a cell.</li>
      <li><strong>Run:</strong> Pick an algorithm and click <strong>Run Algorithm</strong>.</li>
      <li><strong>Reset:</strong> Clear everything with <strong>Reset Grid</strong>.</li>
    </ul>

    <div class="algo-grid">
      <div class="algo-card">
        <div class="algo-name">BFS</div>
        <div class="algo-desc">
          Explores layer by layer from the start. On this grid, it finds the shortest path by number of steps.
        </div>
      </div>
      <div class="algo-card">
        <div class="algo-name">DFS</div>
        <div class="algo-desc">
          Goes as deep as possible before backtracking. Interesting patterns, not guaranteed shortest.
        </div>
      </div>
      <div class="algo-card">
        <div class="algo-name">Dijkstra</div>
        <div class="algo-desc">
          Classic shortest-path algorithm. With uniform costs here, it behaves like an “optimal BFS”.
        </div>
      </div>
      <div class="algo-card">
        <div class="algo-name">A*</div>
        <div class="algo-desc">
          Guides the search using distance to the goal. Often reaches the end faster with fewer visited cells.
        </div>
      </div>
    </div>

    <p class="hint">
      The implementation is intentionally small and readable: plain HTML, CSS, and JavaScript with explicit BFS, DFS,
      Dijkstra and A* logic.
    </p>
  </div>
</aside>
    </main>
  </div>

  <script>
    // --- Core state ---
    const ROWS = 20;
    const COLS = 30;
    const gridEl = document.getElementById("grid");

    let grid = [];
    let start = null;
    let end = null;
    let placing = "wall"; // "wall", "start", "end"

    const toolWall = document.getElementById("tool-wall");
    const toolStart = document.getElementById("tool-start");
    const toolEnd = document.getElementById("tool-end");


    function setTool(mode) {
      placing = mode;
      [toolWall, toolStart, toolEnd].forEach((chip) =>
        chip.classList.remove("active")
      );
      if (mode === "wall") toolWall.classList.add("active");
      if (mode === "start") toolStart.classList.add("active");
      if (mode === "end") toolEnd.classList.add("active");
    }

    toolWall.addEventListener("click", () => setTool("wall"));
    toolStart.addEventListener("click", () => setTool("start"));
    toolEnd.addEventListener("click", () => setTool("end"));

    // Collapsible guide

    function createGrid() {
      gridEl.innerHTML = "";
      grid = [];
      start = null;
      end = null;

      let index = 0;
      for (let r = 0; r < ROWS; r++) {
        const row = [];
        for (let c = 0; c < COLS; c++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.dataset.row = r;
          cell.dataset.col = c;

          // staggered animation delay
          const delay = 0.02 * (index / 6);
          cell.style.setProperty("--delay", `${delay.toFixed(2)}s`);
          index++;

          cell.addEventListener("click", () => handleCellClick(r, c, cell));
          gridEl.appendChild(cell);

          row.push({ r, c, type: "empty", el: cell });
        }
        grid.push(row);
      }
    }

    function handleCellClick(r, c, cell) {
      const node = grid[r][c];

      if (placing === "start") {
        if (start) {
          start.el.classList.remove("start");
          if (start.type === "start") start.type = "empty";
        }
        node.type = "start";
        cell.className = "cell start";
        start = node;
        setTool("wall");
      } else if (placing === "end") {
        if (end) {
          end.el.classList.remove("end");
          if (end.type === "end") end.type = "empty";
        }
        node.type = "end";
        cell.className = "cell end";
        end = node;
        setTool("wall");
      } else {
        // toggle wall
        if (node.type === "wall") {
          node.type = "empty";
          cell.classList.remove("wall");
        } else if (node.type === "empty") {
          node.type = "wall";
          cell.classList.remove("start", "end", "visited", "path");
          cell.classList.add("wall");
        }
      }
    }

    // Keyboard shortcuts to switch tools
    document.addEventListener("keydown", (e) => {
      if (e.key === "s" || e.key === "S") setTool("start");
      if (e.key === "e" || e.key === "E") setTool("end");
    });

    function sleep(ms) {
      return new Promise((res) => setTimeout(res, ms));
    }

    async function visualizePath(path) {
      for (const node of path) {
        if (node.type !== "start" && node.type !== "end") {
          node.el.classList.add("path");
        }
        await sleep(30);
      }
    }

    async function visualizeVisited(list) {
      for (const node of list) {
        if (node.type !== "start" && node.type !== "end") {
          node.el.classList.add("visited");
        }
        await sleep(10);
      }
    }

    function neighbors(node) {
      const dirs = [
        [1, 0],
        [-1, 0],
        [0, 1],
        [0, -1],
      ];
      const list = [];
      for (const [dr, dc] of dirs) {
        const nr = node.r + dr;
        const nc = node.c + dc;
        if (
          nr >= 0 &&
          nr < ROWS &&
          nc >= 0 &&
          nc < COLS &&
          grid[nr][nc].type !== "wall"
        ) {
          list.push(grid[nr][nc]);
        }
      }
      return list;
    }

    function reconstruct(cameFrom, current) {
      const path = [];
      while (cameFrom.has(current)) {
        path.push(current);
        current = cameFrom.get(current);
      }
      return path.reverse();
    }

    // --- Algorithms ---

    async function bfs() {
      const queue = [start];
      const visited = new Set([start]);
      const cameFrom = new Map();
      const visitedOrder = [];

      while (queue.length) {
        const node = queue.shift();
        visitedOrder.push(node);

        if (node === end) {
          await visualizeVisited(visitedOrder);
          const path = reconstruct(cameFrom, node);
          return visualizePath(path);
        }

        for (const neigh of neighbors(node)) {
          if (!visited.has(neigh)) {
            visited.add(neigh);
            queue.push(neigh);
            cameFrom.set(neigh, node);
          }
        }
      }
    }

    async function dfs() {
      const stack = [start];
      const visited = new Set([start]);
      const cameFrom = new Map();
      const visitedOrder = [];

      while (stack.length) {
        const node = stack.pop();
        visitedOrder.push(node);

        if (node === end) {
          await visualizeVisited(visitedOrder);
          const path = reconstruct(cameFrom, node);
          return visualizePath(path);
        }

        for (const neigh of neighbors(node)) {
          if (!visited.has(neigh)) {
            visited.add(neigh);
            stack.push(neigh);
            cameFrom.set(neigh, node);
          }
        }
      }
    }

    async function dijkstra() {
      const dist = new Map();
      const visited = new Set();
      const cameFrom = new Map();
      const visitedOrder = [];

      dist.set(start, 0);

      while (true) {
        let cur = null;
        let best = Infinity;

        for (const row of grid) {
          for (const cell of row) {
            const d = dist.get(cell);
            if (!visited.has(cell) && d !== undefined && d < best) {
              best = d;
              cur = cell;
            }
          }
        }

        if (!cur) break;

        visited.add(cur);
        visitedOrder.push(cur);

        if (cur === end) {
          await visualizeVisited(visitedOrder);
          const path = reconstruct(cameFrom, cur);
          return visualizePath(path);
        }

        for (const neigh of neighbors(cur)) {
          const alt = (dist.get(cur) ?? Infinity) + 1;
          if ((dist.get(neigh) ?? Infinity) > alt) {
            dist.set(neigh, alt);
            cameFrom.set(neigh, cur);
          }
        }
      }
    }

    function h(a, b) {
      return Math.abs(a.r - b.r) + Math.abs(a.c - b.c);
    }

    async function astar() {
      const open = new Set([start]);
      const cameFrom = new Map();
      const g = new Map([[start, 0]]);
      const f = new Map([[start, h(start, end)]]);
      const visitedOrder = [];

      while (open.size) {
        let cur = null;
        let best = Infinity;

        for (const node of open) {
          const score = f.get(node) ?? Infinity;
          if (score < best) {
            best = score;
            cur = node;
          }
        }

        if (!cur) break;

        visitedOrder.push(cur);

        if (cur === end) {
          await visualizeVisited(visitedOrder);
          const path = reconstruct(cameFrom, cur);
          return visualizePath(path);
        }

        open.delete(cur);

        for (const neigh of neighbors(cur)) {
          const tempG = (g.get(cur) ?? Infinity) + 1;
          if (tempG < (g.get(neigh) ?? Infinity)) {
            cameFrom.set(neigh, cur);
            g.set(neigh, tempG);
            f.set(neigh, tempG + h(neigh, end));
            open.add(neigh);
          }
        }
      }
    }

    // --- Controls ---

    document.getElementById("run").addEventListener("click", () => {
      if (!start || !end) {
        alert("Place a Start and End first (use the tools or S / E keys).");
        return;
      }
      const algo = document.getElementById("algo-select").value;
      if (algo === "bfs") bfs();
      else if (algo === "dfs") dfs();
      else if (algo === "dijkstra") dijkstra();
      else astar();
    });

    document.getElementById("reset").addEventListener("click", () => {
      createGrid();
    });

    // Init
    createGrid();
    setTool("wall");
  </script>
</body>
</html>